## 예시
> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.

- 리팩터링이 필요한 이유는 **변경** 때문이다. 잘 작동하고 나중에 변경할 일이 절대 없다면 코드를 현재 상태로 놔둬도 아무런 문제가 없다.
- 하지만 다른 사람이 코드를 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 대책을 마련해야 한다.


## 리팩터링의 첫 단계
- 리팩터링의 첫 단계는 항상 똑같다. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다. 리팩터링에서 테스트의 역할은 굉장히 중요하다!

### 함수 추출하기
- 코드 조각을 별도 함수로 추출하는 방식으로 파악한 정보를 코드에 반영하고, 추출한 함수에 코드가 하는 일을 설명하는 이름 짓기
- 수정 후 곧바로 컴파일하고 테스트해서 실수한 게 없는지 확인하는 습관을 가지자.
  - 한 가지를 수정할 떄마다 테스트하면, 오류가 생기더라도 변경 폭이 작기 때문에 살펴볼 범위도 좁아서 문제를 찾고 해결하기 훨씬 쉽다.
- 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심!
- **컴파일-테스트-커밋** 필수!!

> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

### 임시 변수를 질의 함수로 바꾸기
- 긴 함수를 쪼갤 떄마다 play같은 변수를 제거
- 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해지기 때문(임시 변수는 자신이 속한 루틴에서만 의미 있어서 루틴이 길고 복잡해지기 쉽다)
- 이름 짓기는 중요하면서도 쉽지 않은 작업이다. 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야지만 효과가 있다.

### 반복문을 쪼개면 성능이 느려지지 않을까?
- 이번 사례 정도의 반복문 중복은 성능에 미치는 영향이 미비하다.
- 소프트웨어 성능은 대체로 코드의 몇몇 작은 부분에 의해 결정되므로 그외 부분을 수정한다고 해도 성능 차이를 크게 체감할 수 없다.
- 그러나 **대체로 그렇다**와 **항상 그렇다**는 엄연히 다르다. 때로는 리팩터링이 오히려 성능 저하에 영향을 준다.
- 그럼에도 저자는 개의치 않고 리팩터링을 한다! 잘 다듬어진 코드라야 성능 개선 작업에도 훨씬 수월하기 때문이다!
- 리팩터링 이후 성능이 크게 떨어졌다면 리팩터링 이후 성능 개선 작업을 진행한다. 이 과정에서 코드를 예전으로 되돌리는 경우가 발생할 수도 있지만 대체로 리팩터링 덕분에 성능 개선을 더욱 효과적으로 수행할 수 있다.
- 리팩터링 중간에 테스트를 실패하고 원인을 바로 찾지 못하면 가장 최근 커밋으로 돌아가서 실패한 리팩터링의 단계를 더 쪼갠 후 다시 시도한다(컴파일-테스트-커밋이 습관화되어야 하겠군!).

## 다형성 활용
- 조건부 로직을 명확한 구조로 보완하는 방법으로 객체지향의 핵심 특성인 다형성을 활용하는 것이 자연스럽다.

## 마무리
> 좋은 코드를 가능하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
