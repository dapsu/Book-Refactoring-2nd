## 리팩터링 정의
> 리팩터링: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
> 리팩터링(하다): 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 **재구성**하다.

- 리팩터링은 결국 동작은 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일
- 따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

- 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 것이 비효율적일 것 같지만, 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다.
- 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문이다.
- 리팩터링의 목적: 코드를 이해하고 수정하기 쉽게 만드는 것. 성능은 신경쓰지 않는다.

## 두 개의 모자
> 저자: 나는 소프트웨어를 개발할 때 목적이 '기능 추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다.
- '기능 추가' 모자를 썼을 때에는 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다.
  - 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정
- '리팩터링' 모자를 썼을 때에는 기능 추가는 절대 하지 않기도 다짐한 뒤 오로지 코드 재구성에만 전념한다.
  - 테스트도 새로 만들지 않는다(놓쳤던 부분이나 버그는 제외).
  - 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정
- 전체 작업 시간이 10분 정도로 짧다 해도 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

## 리팩터링하는 이유

### 리팩터링하면 소프트웨어 설계가 좋아진다
아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 코드 구조가 무너지기 시작하면 악효과가 누적된다. 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다. 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.
중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 코드량을 줄인다고 시스템이 빨라지는 것은 아니지만, 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다
내 소스 코드는 컴퓨터만 사용하는 것이 아니다. 몇 달이 지나 누군가 내 코드를 수정하고자 읽게 될 수 있다. 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못하게 된다. (설령 그 개발자가 나 자신일 때가 많다...!) 코드를 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다. 잘 작동하지만 이상적인 구조가 아닌 코드가 있다면 시간을 내서 리팩터링해보자.

### 리팩터링하면 버그를 쉽게 찾을 수 있다
코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.

### 리팩터링하면 프로그래밍 속도를 높일 수 있다
내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.
코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다.

## 언제 리팩터링해야 할까?

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
코드 수정에 앞서 그 코드가 하는 일을 파악해야 한다. 조건부 로직 구조가 이상하지 않는지, 함수 이름은 적절한지 등!

### 쓰레기 줍기 리팩터링
간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.

### 계획된 리팩터링과 수시로 하는 리팩터링
리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 저자는 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른 일을 하는 중에 처리한다.

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 **수정**하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
반면에 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요도 있다. 하지만 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.

### 오래 걸리는 리팩터링
팀 전체가 달려들어도 몇 주 걸리는 대규모 리팩터링도 있다(마이그레이션이 해당할 듯). 이 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 데는 회의적이다. 만약 라이브러리를 교체한다면 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다(추상화로 갈아타기).

### 코드 리뷰에 리팩터링 활용하기
코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다. 경험이 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다. 리팩터링은 다른 이의 코드를 리뷰하는 데 도움된다.


### 리팩터링하지 말아야 할 떄
내부 동작을 잘 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다. 만약 외부 API 다루듯 호출해서 쓰는 코드라면 우선 넘어가자.

## 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하
> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 

### 코드 소유권
코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다.

### 브랜치
독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 이 고통을 줄이고자 많은 이들이 수시로 rebase나 merge를 진행한다. 하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없다. 

### 테스팅
리팩터링은 단계별 변경 폭이 작아서 도중에 발생한 오류의 원인이 될만한 코드 범위가 넓지 않다. 여기서 핵심은 오류를 재빨리 잡는 데 있다. 실제로 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요하다. 즉 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다.
테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 떄문이다.

### 레거시 코드
레거시 시스템을 파악할 떄 리팩터링이 굉장히 도움된다. 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.

### 데이터베이스
데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다. 

## 리팩터링과 소프트웨어 개발 프로세스
자가 테스트 코드 + 리팩터링 = TDD
리팩터링의 첫 번쨰 토대는 자가 테스트 코드다. 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.
팀으로 개발하면서 리팩터링을 하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다. CI를 적극 권장하는 이유이기도 하다.

## 리팩터링 성능
리팩터링하면서 소프트웨어가 느려질 수도 있는건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.
성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발이 더뎌진다.
의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 데 집중한다.